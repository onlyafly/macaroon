#|
Lisp interpreter adapted from Chapter 1 of Christian Queinnec's Lisp in Small Pieces
|#

(load "examples/prelude.mn")
(load "examples/mtest.mn")

(defn get (l n)
  (if (= n 0)
    (first l)
    (get (rest l) (- n 1))))

(defn wrong (&rest args)
    (println "DEBUG wrong:" args)
    (apply panic args))

(def the-false-value false)

(defn evaluate (e env)
    (if (atom? e)
        (cond
            (symbol? e) (lookup e env)
            (or (number? e) (string? e) (char? e) (boolean? e)) e
            else (wrong (concat "Cannot eval: " (str e))))
        (case (first e)
            'quote (frest e)
            'if    (if (not (= (evaluate (get e 1) env) the-false-value))
                     (evaluate (get e 2) env)
                     (evaluate (get e 3) env))
            'begin (eprogn (rest e) env)
            'set!  (update (get e 1)
                           env
                           (evaluate (get e 2) env))
            'fn    (make-function (get e 1)
                                  (rest (rest e))
                                  env)
            else   (invoke
                     (evaluate (first e) env)                
                     (s_evlis (rest e) env)))))

(defn eprogn (es env)
    ;DEBUG (println "s_eprogn:" es)
    (if (not (empty? es))
        (if (not (empty? (rest es)))
            (begin 
                (evaluate (first es) env)
                (eprogn (rest es) env))
            (evaluate (first es) env))
        nil
        ))

;; TODO: Not yet tested
(defn evlis (es env)
    (if (empty? es)
        ()
        (cons (evaluate (first es) env)
              (evlis (rest es) env))))

(defn routine? (n)
  (case (typeof n)
    'function true
    'primitive true
    else false))

(defn invoke (f args)
    (if (routine? f)
        (f args)
        (wrong "Not a function" f)))

;----- Environment

(def env.init ())

(defn make-entry (var val)
    (list var (cell val)))

(defn entry-var (entry)
    (first entry))

(defn entry-val (entry)
    (first (rest entry)))

(defn extend (env vars vals)
    (cond
        (empty? vars)  (if (empty? vals)
                           env
                           (wrong "Too many values"))
        (symbol? vars) (cons (make-entry vars vals) env)
        (list? vars)   (if (empty? vals)
                           (wrong "Too few values")
                           (cons (make-entry (first vars) (first vals))
                                 (extend env (rest vars) (rest vals))))))

(defn lookup (id env)
    (if (empty? env)
        (wrong "No such binding:" id)
        (if (= (entry-var (first env)) id)
            (get-cell (entry-val (first env)))
            (lookup id (rest env)))))

(defn update (id env value)
    (if (empty? env)
        (wrong "No such binding:" id)
        (if (= (entry-var (first env)) id)
            (begin
                (set-cell! (entry-val (first env)) value)
                value)
            (update id (rest env) value))))


;-------------------- Unit Tests --------------------

(defmtest "extend, with symbol"
  (mt=
    (extend () 'a '1)
    (list (list 'a (cell 1)))
    ))

(defmtest "extend, with list"
  (mt=
    (extend () '(a b c) '(1 2 3))
    (list (list 'a (cell 1))
          (list 'b (cell 2))
          (list 'c (cell 3)))
    ))

;-------------------- Integration Tests --------------------

(defmtest "Evaluate atom"
  (mt=
    (evaluate 1 ())
    1))

(defmtest "Evaluate begin"
  (mt=
    (evaluate '(begin 1 2) ())
    2)
  (mt=
    (evaluate '(begin) ())
    nil))

(defmtest "Evaluate a symbol"
  (mt=
    (evaluate 'foo (list (list 'foo (cell 42))))
    42)
    )

(defmtest "Evaluate: set!"
  (mt=
    (evaluate '(set! foo 1776) (list (list 'foo (cell 42))))
    1776)
  (mt=
    (evaluate
        '(begin
            (set! bar 5)
            bar)
        (list (list 'bar (cell 100))))
    5)
    )


(defmtest "Evaluate if"
  (mt=
    (evaluate '(if true 1 2) ())
    1))

#|
(defmtest "Evaluate ="
  (mt=
    (evaluate '(= 45 45) ())
    2))
|#

(mtest-start)