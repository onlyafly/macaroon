;#|
;Lisp interpreter adapted from Chapter 1 of Christian Queinnec's Lisp in Small Pieces
;|#

(load "examples/prelude.mn")
(load "examples/mtest.mn")

;-------------------- REPL --------------------

(defn repl ()
    (defn toplevel ()
        (let (line (read-line))
            (cond
                (= line ":q") (println "Exiting...")
                else (begin
                        (println (evaluate (read-string line) env.global))
                        (toplevel)))))
    (toplevel))

;-------------------- Evaluation --------------------

(defn evaluate (e env)
    (if (atom? e)
        (cond
            (symbol? e) (lookup e env)
            (or (number? e) (string? e) (char? e) (boolean? e)) e
            else (wrong "Cannot eval:" (str e)))
        (if (empty? e)
            (wrong "Cannot eval empty list")
            (case (first e)
                'quote (frest e)
                'if    (if (not (= (evaluate (get e 1) env) the-false-value))
                        (evaluate (get e 2) env)
                        (evaluate (get e 3) env))
                'begin (eprogn (rest e) env)
                'set!  (update (get e 1)
                            env
                            (evaluate (get e 2) env))
                'fn    (make-function (get e 1)
                                    (rest (rest e))
                                    env)
                else   (invoke
                        (evaluate (first e) env)                
                        (evlis (rest e) env))))))

(defn eprogn (es env)
    ;DEBUG (println "s_eprogn:" es)
    (if (not (empty? es))
        (if (not (empty? (rest es)))
            (begin 
                (evaluate (first es) env)
                (eprogn (rest es) env))
            (evaluate (first es) env))
        nil
        ))

;; TODO: Not yet tested
(defn evlis (es env)
    (if (empty? es)
        ()
        (cons (evaluate (first es) env)
              (evlis (rest es) env))))

(defn invoke (f args)
    (if (routine? f)
        (f args)
        (wrong "Not a function" f)))

(defn make-function (vars body env)
    (fn (vals)
        (eprogn body (extend env.global vars vals))))

;-------------------- Environment --------------------

(def env.init ())

(def env.global env.init)

(defn make-entry (var val)
    (list var (cell val)))

(defn entry-var (entry)
    (first entry))

(defn entry-val (entry)
    (first (rest entry)))

(defn extend (env vars vals)
    (cond
        (empty? vars)  (if (empty? vals)
                           env
                           (wrong "Too many values"))
        (symbol? vars) (cons (make-entry vars vals) env)
        (list? vars)   (if (empty? vals)
                           (wrong "Too few values")
                           (cons (make-entry (first vars) (first vals))
                                 (extend env (rest vars) (rest vals))))))

(defn lookup (id env)
    (if (empty? env)
        (wrong "No such binding:" id)
        (if (= (entry-var (first env)) id)
            (get-cell (entry-val (first env)))
            (lookup id (rest env)))))

(defn update (id env value)
    (if (empty? env)
        (wrong "No such binding:" id)
        (if (= (entry-var (first env)) id)
            (begin
                (set-cell! (entry-val (first env)) value)
                value)
            (update id (rest env) value))))

;-------------------- Primitives --------------------

(defn definitial (name val)
    (update! env.global (cons (make-entry name val)
                              env.global)))

(defn defprimitive (name val arity)
    (definitial
        name
        (fn (args)
            (if (= arity (len args))
                (apply val args)
                (wrong "Incorrect arity" (list name args))))))

(definitial 'null ())
(definitial 't true)
(definitial 'f the-false-value)
(defprimitive 'cons cons 2)
(defprimitive 'car first 1)
(defprimitive 'cdr rest 1)
(defprimitive '+ + 2)
(defprimitive 'eq? = 2)
(defprimitive '< < 2)

;-------------------- Helpers --------------------

(defn get (l n)
  (if (= n 0)
    (first l)
    (get (rest l) (- n 1))))

(defn wrong (&rest args)
    (apply panic args))

(def the-false-value false)

(defn routine? (n)
  (case (typeof n)
    'function true
    'primitive true
    else false))

;-------------------- Unit Tests --------------------

(defmtest "extend, with symbol"
  (mt=
    (extend () 'a '1)
    (list (list 'a (cell 1)))
    ))

(defmtest "extend, with list"
  (mt=
    (extend () '(a b c) '(1 2 3))
    (list (list 'a (cell 1))
          (list 'b (cell 2))
          (list 'c (cell 3)))
    ))

;-------------------- Integration Tests --------------------

(defmtest "Evaluate atom"
  (mt=
    (evaluate 1 ())
    1))

(defmtest "Evaluate begin"
  (mt=
    (evaluate '(begin 1 2) ())
    2)
  (mt=
    (evaluate '(begin) ())
    nil))

(defmtest "Evaluate a symbol"
  (mt=
    (evaluate 'foo (list (list 'foo (cell 42))))
    42)
    )

(defmtest "Evaluate: set!"
  (mt=
    (evaluate '(set! foo 1776) (list (list 'foo (cell 42))))
    1776)
  (mt=
    (evaluate
        '(begin
            (set! bar 5)
            bar)
        (list (list 'bar (cell 100))))
    5)
    )


(defmtest "Evaluate if"
  (mt=
    (evaluate '(if true 1 2) ())
    1))

(defmtest "Evaluate fn"
    (mt=
        (evaluate '((fn (a b) a) 1 2) ())
        1))

(defmtest "Evaluate null"
    (mt=
        (evaluate 'null env.global)
        ()))

(defmtest "Evaluate cons"
    (mt=
        (evaluate 'cons env.global)
        (list 1))
    (mt=
        (evaluate '(cons 1 (quote ())) env.global)
        (list 1))
    )

(defmtest "Evaluate <"
    (mt=
        (evaluate '(< 1 0) env.global)
        false))

#|
(defmtest "Evaluate ="
  (mt=
    (evaluate '(= 45 45) ())
    2))
|#

(mtest-start)